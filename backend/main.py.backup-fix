# backend/main.py
import os
import uuid # Импортируем uuid для генерации токенов
import shutil # Добавляем для работы с файлами
from fastapi import FastAPI, Depends, HTTPException, status, APIRouter, BackgroundTasks, Query, File, UploadFile, Form # Добавляем BackgroundTasks для фоновых задач и Query для поиска
from fastapi.security import OAuth2PasswordRequestForm, OAuth2PasswordBearer # Добавляем OAuth2PasswordRequestForm и OAuth2PasswordBearer
from sqlalchemy.orm import Session
from typing import Annotated, List, Optional, Union
from datetime import timedelta, datetime # Импортируем timedelta и datetime
from fastapi.middleware.cors import CORSMiddleware
import smtplib  # Для SMTP-соединения
from email.mime.text import MIMEText  # Для создания email
from email.mime.multipart import MIMEMultipart  # Для создания составных email
from math import ceil
from pydantic import BaseModel  # Для моделей данных
from fastapi.staticfiles import StaticFiles # Для раздачи статических файлов
import secrets
import time

# Импортируем наши модели и функцию для получения сессии БД
from models import User, PatientProfile, DoctorProfile, get_db, DATABASE_URL, engine, Base, DoctorApplication, SessionLocal, ViewedNotification, Consultation, Message, Review, UserNotificationSettings # Добавляем UserNotificationSettings
# Импортируем функции для работы с паролями и JWT, а также зависимости для аутентификации и ролей
# get_current_user и require_role используются как зависимости в эндпоинтах
from auth import get_password_hash, verify_password, create_access_token, SECRET_KEY, ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES, get_current_user, require_role, authenticate_user, get_current_active_user, SECURE_TOKEN_LENGTH, Token as TokenModel, verify_google_token, authenticate_google_user, create_csrf_token, verify_csrf_token, check_login_attempts, LOGIN_ATTEMPTS

# Импортируем pydantic модели для валидации данных запросов и ответов
from schemas import UserCreate, UserResponse, Token, PatientProfileCreateUpdate, PatientProfileResponse, DoctorProfileCreateUpdate, DoctorProfileResponse, Field, DoctorFilter, DoctorBrief, DoctorDetail, DoctorListResponse, DoctorApplicationCreate, DoctorApplicationResponse, DoctorApplicationProcessRequest, DoctorApplicationListResponse # Импортируем Field (хотя он нужен только в schemas.py), DoctorFilter, DoctorBrief, DoctorDetail, DoctorListResponse

from dotenv import load_dotenv
load_dotenv()

# Создаем директорию для загрузки файлов, если она еще не существует
UPLOAD_DIR = os.path.join(os.getcwd(), "uploads")
if not os.path.exists(UPLOAD_DIR):
    os.makedirs(UPLOAD_DIR)

# Создаем поддиректории для разных типов файлов
PHOTO_DIR = os.path.join(UPLOAD_DIR, "photos")
DIPLOMA_DIR = os.path.join(UPLOAD_DIR, "diplomas")
LICENSE_DIR = os.path.join(UPLOAD_DIR, "licenses")

# Создаем директории, если они еще не существуют
for directory in [PHOTO_DIR, DIPLOMA_DIR, LICENSE_DIR]:
    if not os.path.exists(directory):
        os.makedirs(directory)


# Определяем базовый URL для подтверждения email (адрес страницы фронтенда, куда пользователь перейдет по ссылке из письма)
# В реальном проекте это должна быть переменная окружения, читаемая из .env!
VERIFICATION_BASE_URL = os.getenv("VERIFICATION_BASE_URL", "http://localhost:5173/verify-email") # <-- TODO: Замени на актуальный URL твоего фронтенда!

# Email конфигурация
EMAIL_HOST = os.getenv("EMAIL_HOST", "smtp.gmail.com")
EMAIL_PORT = int(os.getenv("EMAIL_PORT", "587"))
EMAIL_USERNAME = os.getenv("EMAIL_USERNAME", "your_email@gmail.com")
EMAIL_PASSWORD = os.getenv("EMAIL_PASSWORD", "your_app_password")
EMAIL_FROM = os.getenv("EMAIL_FROM", "your_email@gmail.com")


# Создаем таблицы в БД при старте приложения.
# Это удобно для разработки, чтобы не запускать 'alembic upgrade head' каждый раз при локальном старте.
# В продакшене лучше использовать только миграции (убрать этот вызов).
if DATABASE_URL is None:
    # Проверка на наличие DATABASE_URL происходит при импорте models.py, но дублируем на всякий случай.
    raise ValueError("DATABASE_URL environment variable is not set.")
try:
    # Попытка создать таблицы. Если они уже есть, SQLAlchemy просто проигнорирует это.
    # Может выбросить исключение, если нет соединения с БД.
    Base.metadata.create_all(bind=engine)
except Exception as e:
    # Логируем ошибку, если не удалось подключиться к БД при старте (например, БД не запущена).
    # Это полезно для отладки.
    print(f"Error creating database tables: {e}")
    # Можно также решить, стоит ли останавливать приложение, если БД недоступна при старте.
    # Для разработки можно просто вывести ошибку, для продакшена, возможно, лучше остановить.

# Создаем администратора при первом запуске приложения (если его еще нет)
try:
    with SessionLocal() as db:
        admin_exists = db.query(User).filter(User.role == "admin").first()
        if not admin_exists:
            # Создаем первого админа с дефолтным логином и паролем
            admin_password = get_password_hash("admin")
            admin_user = User(
                email="admin@medcare.com",
                hashed_password=admin_password,
                is_active=True,
                role="admin"
            )
            db.add(admin_user)
            db.commit()
            print("Администратор по умолчанию создан: admin@medcare.com / admin")
except Exception as e:
    print(f"Error creating default admin: {e}")


app = FastAPI() # Создаем экземпляр FastAPI приложения
origins = [
    "http://localhost", # Разрешаем доступ с localhost (обычно для статики)
    "http://localhost:5173", # <--- РАЗРЕШАЕМ ДОСТУП С НАШЕГО ФРОНТЕНДА НА VITE!
    "http://127.0.0.1", # Разрешаем доступ с 127.0.0.1 (аналог localhost)
    "http://127.0.0.1:5173", # <--- РАЗРЕШАЕМ ДОСТУП С НАШЕГО ФРОНТЕНДА НА VITE (через 127.0.0.1)!
    # TODO: Добавить другие источники, если фронтенд будет доступен по другому адресу или порту
    # TODO: В продакшене здесь должен быть домен твоего сайта!
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins, # Список разрешенных источников
    allow_credentials=True, # Разрешаем использование cookie и учетных данных в запросах (например, для будущих сессий, хотя сейчас используем JWT)
    allow_methods=["*"], # Разрешаем все HTTP методы (GET, POST, PUT, DELETE и т.д.)
    allow_headers=["*"], # Разрешаем все заголовки в запросах (включая Authorization)
)

# Монтируем StaticFiles для доступа к загруженным файлам
app.mount("/uploads", StaticFiles(directory=UPLOAD_DIR), name="uploads")

# Dependency для получения сессии базы данных. Используется в роутах для взаимодействия с БД.
# Annotated - современный способ указания типа и зависимости.
DbDependency = Annotated[Session, Depends(get_db)]

# Dependency для получения текущего авторизованного пользователя. Используется в защищенных роутах.
CurrentUser = Annotated[User, Depends(get_current_user)]


# --- Функция для отправки письма с помощью SMTP ---
def send_verification_email(email: str, token: str):
    """
    Отправляет email с ссылкой для подтверждения почты.

    Args:
        email (str): Email пользователя
        token (str): Токен для подтверждения
        
    Note:
        В продакшене данная функция должна использовать реальный SMTP сервер.
    """
    # Формируем ссылку для подтверждения
    verification_link = f"{VERIFICATION_BASE_URL}?token={token}"
    
    try:
        # Создаем объект сообщения
        msg = MIMEMultipart()
        msg['From'] = EMAIL_FROM
        msg['To'] = email
        msg['Subject'] = "Подтверждение регистрации в MedCare"
        
        # Создаем HTML-тело письма
        html = f"""
        <html>
            <body style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; line-height: 1.5;">
                <div style="background-color: #f8f9fa; padding: 20px; border-radius: 10px; border: 1px solid #e9ecef;">
                    <h2 style="color: #3b82f6; margin-bottom: 20px;">Подтверждение регистрации</h2>
                    <p>Спасибо за регистрацию в системе MedCare!</p>
                    <p>Для активации аккаунта, пожалуйста, перейдите по ссылке:</p>
                    <p style="margin: 30px 0;">
                        <a href="{verification_link}" 
                           style="background-color: #3b82f6; color: white; padding: 10px 20px; text-decoration: none; border-radius: 5px; font-weight: bold;">
                            Подтвердить email
                        </a>
                    </p>
                    <p>Если вы не регистрировались на нашем сайте, просто проигнорируйте это письмо.</p>
                    <p>С уважением,<br>Команда MedCare</p>
                </div>
            </body>
        </html>
        """
        
        # Добавляем HTML-часть к сообщению
        msg.attach(MIMEText(html, 'html'))
        
        # Устанавливаем соединение с SMTP-сервером
        server = smtplib.SMTP(EMAIL_HOST, EMAIL_PORT)
        server.starttls()  # Включаем шифрование
        
        # Авторизуемся на сервере
        server.login(EMAIL_USERNAME, EMAIL_PASSWORD)
        
        # Отправляем письмо
        server.send_message(msg)
        
        # Закрываем соединение
        server.quit()
        
        print(f"Verification email sent to: {email}")
        print(f"Link: {verification_link}")
        
    except Exception as e:
        # В случае ошибки отправки, выводим ошибку в консоль
        print(f"Error sending email: {e}")
        
        # Выводим ссылку в консоль (как запасной вариант)
        print(f"\n--- EMAIL VERIFICATION FAILED, SHOWING LINK ---")
    print(f"To: {email}")
    print(f"Subject: Confirm your email address")
    print(f"Link: {verification_link}")
    print(f"--------------------------------------------\n")

# --- Роуты для базовых пользователей и аутентификации ---

# Эндпоинт для тестовой проверки статуса сервера. Не требует авторизации.
@app.get("/status")
def get_status():
    """
    Возвращает статус работы бэкенда.
    """
    return {"status": "Backend is running"}


# Эндпоинт для регистрации нового пользователя. Не требует авторизации.
@app.post("/register", response_model=Token, status_code=status.HTTP_201_CREATED) # Изменяем ответ на Token вместо UserResponse
def register_user(
    user: UserCreate, # Pydantic модель для валидации входных данных запроса
    db: DbDependency, # Зависимость для получения сессии БД
    background_tasks: BackgroundTasks # Зависимость для выполнения задач в фоновом режиме (например, отправки письма)
):
    """
    Регистрация нового пользователя (Пациента, Врача или Администратора).
    Пользователь будет создан как неактивный и получит ссылку для подтверждения email.
    Возвращает токен для автоматического входа.
    """
    # Проверяем, существует ли пользователь с таким email в базе данных
    db_user = db.query(User).filter(User.email == user.email).first()
    if db_user:
        # Проверяем, через какой провайдер был зарегистрирован пользователь
        if db_user.auth_provider == "google":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, 
                detail="This email is already registered with Google. Please use Google login."
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, 
                detail="Email already registered. Please login or use password recovery if needed."
            )

    # Хешируем пароль перед сохранением в базе данных. НИКОГДА не храните пароли в открытом виде!
    hashed_password = get_password_hash(user.password)

    # Проверяем сложность пароля
    if len(user.password) < 8:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Password must be at least 8 characters long"
        )

    # Генерируем уникальный токен подтверждения email (используем UUID - Universally Unique Identifier)
    verification_token = str(uuid.uuid4())
    # Сохраняем метку времени создания токена (для проверки срока действия)
    token_created_at = datetime.utcnow()

    # Создаем новый объект пользователя SQLAlchemy на основе данных из запроса и сгенерированных полей
    new_user = User(
        email=user.email,
        hashed_password=hashed_password,
        is_active=False, # <--- Новый пользователь создается как НЕАКТИВНЫЙ
        role=user.role,
        auth_provider="email", # Явно указываем, что пользователь зарегистрирован через email
        email_verification_token=verification_token, # Сохраняем токен подтверждения в БД
        email_verification_token_created_at=token_created_at # Сохраняем время создания токена в БД
    )

    # Добавляем нового пользователя в сессию базы данных и сохраняем изменения (commit)
    db.add(new_user)
    db.commit()
    # Обновляем объект new_user, чтобы получить сгенерированный базой данных id и другие актуальные поля
    db.refresh(new_user)

    # Отправляем письмо с подтверждением email в фоновом режиме.
    # BackgroundTasks позволяют выполнить функцию асинхронно, не блокируя ответ на запрос регистрации.
    background_tasks.add_task(send_verification_email, new_user.email, verification_token)

    # Создаем и возвращаем JWT токен для автоматического входа
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": new_user.email, "role": new_user.role},
        expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


# Эндпоинт для авторизации (получения JWT токена). Не требует авторизации, но проверяет учетные данные.
# Используем стандартную форму OAuth2 Password Request Form (email/password).
@app.post("/token", response_model=Token) # response_model=Token указывает, что в ответ ожидается Pydantic модель Token
async def login_for_access_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()], # Зависимость для получения стандартной формы email/password
    db: DbDependency # Зависимость для получения сессии БД
):
    """
    Аутентификация пользователя и получение JWT токена доступа.
    Используется стандартный OAuth2 формат для username/password (где username - это email).
    """
    try:
        # Проверяем, существует ли пользователь 
        db_user = db.query(User).filter(User.email == form_data.username).first()
        
        # Если пользователь не найден, возвращаем общую ошибку аутентификации
        if not db_user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )

        # Проверяем, не пытается ли пользователь Google войти с паролем
        if db_user.auth_provider == "google":
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="This account was registered with Google. Please use Google login instead."
            )
        
        if not verify_password(form_data.password, db_user.hashed_password):
            # Неверный пароль
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Проверяем активацию аккаунта
        if not db_user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Please verify your email address before logging in.",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Если все проверки пройдены успешно, создаем токен доступа
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": db_user.email, "id": db_user.id, "role": db_user.role},
            expires_delta=access_token_expires
        )
        
        return {"access_token": access_token, "token_type": "bearer"}
    except Exception as e:
        # Логируем ошибку и возвращаем общую ошибку аутентификации
        print(f"Login error: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication failed",
            headers={"WWW-Authenticate": "Bearer"},
        )


    # Для дополнительной безопасности еще раз проверяем пароль
    if not verify_password(form_data.password, user.hashed_password):
        # Регистрируем неудачную попытку входа
        LOGIN_ATTEMPTS.setdefault(form_data.username, []).append(time.time())
        
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Если пользователь не активирован, возвращаем ошибку
    if not user.is_active:
         raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Please verify your email address before logging in.",
            headers={"WWW-Authenticate": "Bearer"},
        )

    # Если аутентификация прошла успешно, создаем токен доступа (JWT)
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    # Создаем payload для JWT токена с id пользователя (sub - subject в терминологии JWT) и ролью
    access_token = create_access_token(
        data={"sub": user.email, "id": user.id, "role": user.role},
        expires_delta=access_token_expires
    )

    # Очищаем запись о попытках входа
    if form_data.username in LOGIN_ATTEMPTS:
        LOGIN_ATTEMPTS[form_data.username] = []

    # Возвращаем токен доступа в соответствии с моделью Token, определенной в schemas.py
    return {"access_token": access_token, "token_type": "bearer"}


# Эндпоинт для получения информации о текущем авторизованном пользователе. Требует авторизацию.
@app.get("/users/me", response_model=UserResponse) # response_model=UserResponse для форматирования ответа
# Используем зависимость CurrentUser, которая сама использует get_current_user для проверки токена.
def read_users_me(current_user: CurrentUser):
    """
    Получить информацию о текущем авторизованном пользователе.
    Доступно для всех авторизованных пользователей.
    """
    # Если get_current_user успешно выполнился, current_user содержит объект SQLAlchemy модели User.
    # Возвращаем этот объект. Pydantic UserResponse с from_attributes=True преобразует его в JSON.
    return current_user


# --- НОВЫЙ ЭНДПОИНТ ДЛЯ ПОДТВЕРЖДЕНИЯ EMAIL ---
# Доступен по ссылке из письма, не требует авторизации.
@app.get("/verify-email", response_model=Token)
def verify_email(token: str, db: DbDependency): # Принимает токен как параметр запроса (?token=...)
    """
    Подтверждение email по токену из письма.
    Активирует пользователя, если токен валиден и не просрочен.
    Возвращает JWT токен для автоматического входа.
    """
    # Настройки времени жизни токена подтверждения email (например, 24 часа)
    # TODO: Вынести это в настройки или переменные окружения
    VERIFICATION_TOKEN_EXPIRE_HOURS = 24

    # Ищем пользователя в базе данных по предоставленному токену подтверждения email
    user = db.query(User).filter(User.email_verification_token == token).first()

    if user is None:
        # Проверяем, возможно пользователь уже подтвердил email (токен был использован)
        # Ищем пользователей с is_active=True и отсутствующим токеном
        active_users = db.query(User).filter(
            User.is_active == True,
            User.email_verification_token.is_(None)
        ).all()
        
        # Если есть активные пользователи, возможно один из них использовал данный токен
        if active_users:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid verification token. Email may have already been verified."
            )
        else:
            # Если токен не найден в базе данных и нет активных пользователей, он недействителен.
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST, # 400 Bad Request - некорректный запрос/токен
                detail="Invalid verification token"
            )

    # Проверяем, не истек ли срок действия токена.
    # Сравниваем текущее время (UTC) с временем создания токена.
    token_lifetime = datetime.utcnow() - user.email_verification_token_created_at
    if token_lifetime > timedelta(hours=VERIFICATION_TOKEN_EXPIRE_HOURS):
        # Если разница во времени превышает установленный срок жизни токена.
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, # 400 Bad Request - просроченный токен
            detail="Verification token expired"
        )

    # Если токен найден, не просрочен и связан с существующим пользователем, активируем пользователя.
    user.is_active = True
    # Очищаем поля токена после использования для безопасности (токен становится одноразовым).
    user.email_verification_token = None
    user.email_verification_token_created_at = None

    # Сохраняем изменения в базе данных
    db.commit()
    db.refresh(user) # Обновляем объект пользователя, чтобы убедиться, что изменения сохранены

    # Создаем и возвращаем JWT токен для автоматического входа
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email, "role": user.role},
        expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


# --- Роуты для профилей ---

# Эндпоинт для создания или обновления профиля Пациента. Требует авторизацию и роли 'patient'.
@app.post("/patients/profiles", response_model=PatientProfileResponse, status_code=status.HTTP_201_CREATED)
def create_patient_profile(
    profile_data: PatientProfileCreateUpdate, # Данные профиля из запроса (Pydantic модель)
    db: DbDependency, # Зависимость для сессии БД
    # Зависимость для получения текущего пользователя и проверки его роли.
    # Только пользователь с ролью 'patient' сможет успешно пройти эту зависимость.
    current_user: Annotated[User, Depends(require_role("patient"))]
):
    """
    Создать или обновить профиль Пациента для текущего авторизованного пользователя.
    Доступно только для пользователей с ролью 'patient'.
    """
    # Проверяем, существует ли профиль пациента для текущего пользователя (по user_id, связанному с current_user.id)
    db_profile = db.query(PatientProfile).filter(PatientProfile.user_id == current_user.id).first()

    if db_profile:
        # Если профиль уже есть, обновляем его поля на основе данных из запроса.
        # profile_data.model_dump(exclude_unset=True) создает словарь из Pydantic модели,
        # исключая поля, которые не были явно указаны в запросе (None поля включаются, если они указаны).
        for key, value in profile_data.model_dump(exclude_unset=True).items():
            # Обновляем атрибуты объекта SQLAlchemy db_profile
            setattr(db_profile, key, value)
        db.commit() # Сохраняем изменения в БД
        db.refresh(db_profile) # Обновляем объект из БД
        return db_profile # Возвращаем обновленный профиль
    else:
        # Если профиля нет, создаем новый объект PatientProfile
        new_profile = PatientProfile(
            user_id=current_user.id, # Связываем профиль с текущим пользователем
            **profile_data.model_dump() # Распаковываем данные из Pydantic модели PatientProfileCreateUpdate в аргументы конструктора PatientProfile
        )
        db.add(new_profile) # Добавляем новый профиль в сессию
        db.commit() # Сохраняем в БД
        db.refresh(new_profile) # Обновляем объект
        return new_profile # Возвращаем созданный профиль


# Эндпоинт для создания или обновления профиля Врача. Требует авторизацию и роли 'doctor'.
@app.post("/doctors/profiles", response_model=DoctorProfileResponse, status_code=status.HTTP_201_CREATED)
def create_doctor_profile(
    profile_data: DoctorProfileCreateUpdate, # Данные профиля из запроса
    db: DbDependency, # Сессия БД
    current_user: Annotated[User, Depends(require_role("doctor"))] # Требуем роль 'doctor'
):
    """
    Создать или обновить профиль Врача для текущего авторизованного пользователя.
    Доступно только для пользователей с ролью 'doctor'.
    """
    # Проверяем, существует ли профиль врача для текущего пользователя
    db_profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == current_user.id).first()

    if db_profile:
        # Если профиль уже есть, обновляем его
        for key, value in profile_data.model_dump(exclude_unset=True).items():
            # Если врач пытается изменить статус is_active, проверяем, что врач верифицирован
            if key == 'is_active' and value is not None:
                # Если врач не верифицирован, он не может активировать свой профиль
                if not db_profile.is_verified and value == True:
                    raise HTTPException(
                        status_code=status.HTTP_403_FORBIDDEN, 
                        detail="Активировать профиль может только верифицированный врач")
                # Обновляем is_active только для верифицированных врачей или при деактивации
                if db_profile.is_verified or value == False:
                    setattr(db_profile, key, value)
            else:
                # Обновляем остальные поля без ограничений
                setattr(db_profile, key, value)
        db.commit()
        db.refresh(db_profile)
        return db_profile
    else:
        # Если профиля нет, создаем новый
        # Не позволяем создавать профиль со статусом is_active=True, пока не верифицирован
        new_profile_data = profile_data.model_dump()
        if 'is_active' in new_profile_data and new_profile_data['is_active'] == True:
            new_profile_data['is_active'] = False  # По умолчанию профиль неактивен
        
        new_profile = DoctorProfile(user_id=current_user.id, **new_profile_data)
        db.add(new_profile)
        db.commit()
        db.refresh(new_profile)
        return new_profile


# Эндпоинт для получения профиля текущего авторизованного пользователя (Пациента или Врача). Требует авторизацию.
# response_model=Annotated[PatientProfileResponse | DoctorProfileResponse, ...] указывает, что эндпоинт может вернуть одну из двух Pydantic моделей.
@app.get("/users/me/profile", response_model=Annotated[PatientProfileResponse | DoctorProfileResponse, ...])
def read_my_profile(db: DbDependency, current_user: CurrentUser): # Требует просто авторизации
    """
    Получить профиль текущего авторизованного пользователя (Пациента или Врача).
    Доступно для всех авторизованных пользователей с ролью 'patient' или 'doctor'.
    """
    # Проверяем роль текущего пользователя и ищем соответствующий профиль.
    if current_user.role == "patient":
        profile = db.query(PatientProfile).filter(PatientProfile.user_id == current_user.id).first()
        if profile is None:
            # Если профиль пациента не найден (хотя пользователь есть и роль 'patient')
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient profile not found")
        # Возвращаем объект SQLAlchemy профиля пациента. FastAPI/Pydantic преобразует его в PatientProfileResponse.
        return profile
    elif current_user.role == "doctor":
        profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == current_user.id).first()
        if profile is None:
            # Если профиль врача не найден
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Doctor profile not found")
        # Возвращаем объект SQLAlchemy профиля врача. FastAPI/Pydantic преобразует его в DoctorProfileResponse.
        return profile
    else:
        # Если у пользователя роль, для которой профиль не предусмотрен (например, 'admin')
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="User role does not have a profile type")


# Эндпоинт для получения публичного профиля Врача по ID пользователя Врача. Пока не требует авторизации.
@app.get("/doctors/{user_id}/profile", response_model=DoctorProfileResponse)
def read_doctor_profile_by_user_id(user_id: int, db: DbDependency): # Не требует авторизации (пока)
    """
    Получить публичный профиль Врача по ID пользователя Врача.
    Доступно без авторизации (пока).
    """
    # Ищем пользователя по предоставленному ID
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        # Если пользователь не найден
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")

    # Проверяем, что найденный пользователь является Врачом.
    if user.role != "doctor":
        # Если пользователь не врач, возвращаем 404 (или 400, в зависимости от того, хотим ли мы скрывать существование пользователя)
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User is not a doctor or their profile is not public")

    # Ищем профиль Врача, связанный с этим пользователем.
    profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == user.id).first()
    if profile is None:
        # Если профиль врача не найден (хотя пользователь есть и роль 'doctor')
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Doctor profile not found for this user")

    # Возвращаем объект SQLAlchemy профиля врача. FastAPI/Pydantic преобразует его в DoctorProfileResponse.
    return profile


# --- Эндпоинты для поиска врачей ---

# Получение списка всех врачей с опциональной фильтрацией
@app.get("/api/doctors", response_model=DoctorListResponse, tags=["doctors"])
async def get_doctors(
    db: Session = Depends(get_db),
    current_user: Optional[User] = Depends(get_current_user),  # Опционально, может быть None для публичного доступа
    specialization: Optional[str] = Query(None, description="Фильтр по специализации"),
    district: Optional[str] = Query(None, description="Фильтр по району практики врача"),
    min_price: Optional[int] = Query(None, description="Минимальная стоимость"),
    max_price: Optional[int] = Query(None, description="Максимальная стоимость"),
    page: int = Query(1, description="Номер страницы (начиная с 1)"),
    size: int = Query(10, description="Размер страницы (количество элементов)")
):
    """
    Получение списка всех врачей с возможностью фильтрации по специализации, району практики и диапазону цен.
    Поддерживает пагинацию для большого количества результатов.
    """
    # Создаем базовый запрос на получение всех активных и верифицированных врачей
    query = db.query(DoctorProfile).filter(
        DoctorProfile.is_active == True,
        DoctorProfile.is_verified == True
    )
    
    # Применяем фильтры только если они явно указаны
    if specialization:
        # Используем точное совпадение специализации
        query = query.filter(DoctorProfile.specialization == specialization)
        
    if district:
        # Используем точное совпадение района
        query = query.filter(DoctorProfile.district == district)
    # Если пользователь авторизован как пациент и у него указан район, фильтруем по району
    elif current_user and current_user.role == 'patient':
        patient_profile = db.query(PatientProfile).filter(PatientProfile.user_id == current_user.id).first()
        if patient_profile and patient_profile.district:
            query = query.filter(DoctorProfile.district == patient_profile.district)
        
    if min_price is not None:
        query = query.filter(DoctorProfile.cost_per_consultation >= min_price)
        
    if max_price is not None:
        query = query.filter(DoctorProfile.cost_per_consultation <= max_price)
    
    # Считаем общее количество записей после применения фильтров
    total = query.count()
    
    # Добавляем пагинацию
    pages = ceil(total / size) if total > 0 else 0
    
    # Проверка корректности номера страницы
    if page < 1:
        page = 1
    elif page > pages and pages > 0:
        page = pages
    
    # Применяем пагинацию
    offset = (page - 1) * size
    doctors = query.offset(offset).limit(size).all()
    
    # Формируем ответ
    return {
        "items": doctors,
        "total": total,
        "page": page,
        "size": size,
        "pages": pages
    }

# Модель для расширенной информации о враче
class DoctorDetailResponse(BaseModel):
    id: int
    user_id: int
    full_name: str
    specialization: str
    experience: str
    education: str
    cost_per_consultation: int
    practice_areas: str
    district: Optional[str] = None  # Делаем поле опциональным
    is_verified: bool
    is_active: bool
    rating: float = 0.0
    reviews_count: int = 0
    
    class Config:
        from_attributes = True

# Получение детальной информации о враче по ID
@app.get("/api/doctors/{doctor_id}", response_model=DoctorDetailResponse, tags=["doctors"])
async def get_doctor_by_id(
    doctor_id: int,
    db: Session = Depends(get_db),
    current_user: Optional[User] = Depends(get_current_user)  # Опционально для публичного доступа
):
    """
    Получение детальной информации о враче по ID.
    Доступно как для авторизованных, так и для неавторизованных пользователей.
    """
    doctor = db.query(DoctorProfile).filter(DoctorProfile.id == doctor_id).first()
    
    if not doctor:
        raise HTTPException(status_code=404, detail="Врач не найден")
    
    # Подготавливаем ответ
    doctor_detail = DoctorDetailResponse.model_validate(doctor)
    
    # Получаем средний рейтинг и количество отзывов
    # Сначала получаем все завершенные консультации этого врача
    consultation_ids = db.query(Consultation.id).filter(
        Consultation.doctor_id == doctor.user_id,
        Consultation.status == "completed"
    ).subquery()
    
    # Затем получаем отзывы для этих консультаций
    reviews = db.query(Review).filter(Review.consultation_id.in_(consultation_ids)).all()
    
    # Рассчитываем средний рейтинг и количество отзывов
    if reviews:
        total_rating = sum(review.rating for review in reviews)
        doctor_detail.reviews_count = len(reviews)
        doctor_detail.rating = round(total_rating / len(reviews), 1)  # Округляем до 1 десятичной цифры
    
    return doctor_detail


# --- TODO: Добавить дополнительные эндпоинты (консультации, отзывы, платежи) ---

# Модель для Google OAuth запроса
class GoogleAuthRequest(BaseModel):
    code: str

# Добавляем новый маршрут для Google OAuth авторизации
@app.post("/auth/google", response_model=Token)
async def google_auth(
    data: GoogleAuthRequest,
    db: DbDependency
):
    """
    Обработка авторизации через Google OAuth.
    Принимает код авторизации от Google, получает данные пользователя,
    создает/обновляет пользователя в БД и возвращает JWT-токен.
    """
    try:
        # Верифицируем код авторизации и получаем данные пользователя от Google
        try:
            google_data = await verify_google_token(data.code)
        except HTTPException as e:
            if "invalid_grant" in str(e):
                # Это часто происходит при повторном использовании кода авторизации
                raise HTTPException(
                    status_code=status.HTTP_400_BAD_REQUEST,
                    detail="Google authorization code has already been used or expired. Please try again with a new authentication flow.",
                    headers={"WWW-Authenticate": "Bearer"},
                )
            # Пробрасываем исходное исключение, если это не invalid_grant
            raise
        
        # Аутентифицируем или создаем пользователя на основе данных Google
        user = await authenticate_google_user(google_data, db)
        
        # Создаем JWT токен для пользователя
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.email, "role": user.role},
            expires_delta=access_token_expires
        )
        
        # Возвращаем токен
        return {"access_token": access_token, "token_type": "bearer"}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"Google authentication failed: {str(e)}",
            headers={"WWW-Authenticate": "Bearer"},
        )


# Класс для хранения данных профиля пользователя после Google регистрации
class UserProfileData(BaseModel):
    role: str = "patient"  # По умолчанию - пациент
    full_name: str
    contact_phone: Optional[str] = None
    contact_address: Optional[str] = None
    district: Optional[str] = None  # Район


# Эндпоинт для создания/обновления профиля пользователя после Google авторизации
@app.post("/users/me/google-profile", response_model=Union[PatientProfileResponse, DoctorProfileResponse])
async def create_update_google_profile(
    profile_data: UserProfileData,
    db: DbDependency,
    current_user: CurrentUser
):
    """
    Создает или обновляет профиль пользователя после авторизации через Google.
    """
    # Проверяем, существует ли у пользователя профиль
    if profile_data.role == "patient":
        # Проверяем, существует ли профиль пациента
        profile = db.query(PatientProfile).filter(PatientProfile.user_id == current_user.id).first()
        
        if not profile:
            # Создаем новый профиль пациента
            profile = PatientProfile(
                user_id=current_user.id,
                full_name=profile_data.full_name,
                contact_phone=profile_data.contact_phone,
                contact_address=profile_data.contact_address
            )
            db.add(profile)
        else:
            # Обновляем существующий профиль
            profile.full_name = profile_data.full_name
            if profile_data.contact_phone:
                profile.contact_phone = profile_data.contact_phone
            if profile_data.contact_address:
                profile.contact_address = profile_data.contact_address
        
        # Если роль пользователя отличается от указанной, обновляем её
        if current_user.role != "patient":
            current_user.role = "patient"
        
        db.commit()
        db.refresh(profile)
        return profile
        
    elif profile_data.role == "doctor":
        # Проверяем, существует ли профиль врача
        profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == current_user.id).first()
        
        # Данные для профиля врача нужно будет запросить дополнительно
        # Здесь мы создаем только базовый профиль
        if not profile:
            profile = DoctorProfile(
                user_id=current_user.id,
                full_name=profile_data.full_name,
                specialization="Общая практика",  # Дефолтное значение
                experience="",
                education="",
                cost_per_consultation=1000,  # Дефолтное значение
                practice_areas=profile_data.district if profile_data.district else ""
            )
            db.add(profile)
        else:
            # Обновляем только имя, остальные данные нужно обновлять через другой эндпоинт
            profile.full_name = profile_data.full_name
            if profile_data.district:
                profile.practice_areas = profile_data.district
        
        # Если роль пользователя отличается от указанной, обновляем её
        if current_user.role != "doctor":
            current_user.role = "doctor"
            
        db.commit()
        db.refresh(profile)
        return profile
    
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid role specified. Must be 'patient' or 'doctor'."
        )


# Эндпоинт для получения списка районов Ташкента
@app.get("/api/districts", response_model=List[str])
async def get_districts():
    """Возвращает список районов Ташкента"""
    districts = [
        "Алмазарский район",
        "Бектемирский район",
        "Мирабадский район",
        "Мирзо-Улугбекский район",
        "Сергелийский район",
        "Учтепинский район",
        "Чиланзарский район",
        "Шайхантаурский район",
        "Юнусабадский район",
        "Яккасарайский район",
        "Яшнабадский район"
    ]
    return districts

@app.get("/api/specializations", response_model=List[str])
async def get_specializations():
    """Возвращает список специализаций врачей"""
    specializations = [
        "Терапевт",
        "Кардиолог",
        "Невролог",
        "Хирург",
        "Педиатр",
        "Офтальмолог",
        "Стоматолог",
        "Гинеколог",
        "Уролог",
        "Эндокринолог",
        "Дерматолог",
        "Психиатр",
        "Онколог",
        "Отоларинголог (ЛОР)",
        "Ортопед"
    ]
    return specializations

# --- Роуты для заявок на роль врача ---

# Эндпоинт для подачи заявки на роль врача
@app.post("/doctor-applications", response_model=DoctorApplicationResponse, status_code=status.HTTP_201_CREATED)
async def create_doctor_application(
    full_name: str = Form(...),
    specialization: str = Form(...),
    experience: str = Form(...),
    education: str = Form(...),
    license_number: str = Form(...),
    additional_info: Optional[str] = Form(None),
    photo: Optional[UploadFile] = File(None),
    diploma: Optional[UploadFile] = File(None),
    license_doc: Optional[UploadFile] = File(None),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Создает новую заявку на получение роли врача.
    
    Args:
        form_data: Данные формы заявки
        photo: Фото врача
        diploma: Скан диплома
        license_doc: Скан лицензии
        db: Сессия базы данных
        current_user: Текущий пользователь
        
    Returns:
        DoctorApplicationResponse: Данные созданной заявки
    """
    # Проверяем, что пользователь не является уже врачом
    if current_user.role == "doctor":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="У вас уже есть роль врача"
        )
    
    # Проверяем, нет ли уже ожидающей заявки от этого пользователя
    existing_application = db.query(DoctorApplication).filter(
        DoctorApplication.user_id == current_user.id,
        DoctorApplication.status == "pending"
    ).first()
    
    if existing_application:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="У вас уже есть ожидающая рассмотрения заявка"
        )
    
    # Создаем новую заявку
    new_application = DoctorApplication(
        user_id=current_user.id,
        full_name=full_name,
        specialization=specialization,
        experience=experience,
        education=education,
        license_number=license_number,
        additional_info=additional_info
    )
    
    # Обрабатываем загруженные файлы
    if photo:
        file_extension = os.path.splitext(photo.filename)[1]
        filename = f"{uuid.uuid4()}{file_extension}"
        file_path = os.path.join(PHOTO_DIR, filename)
        
        # Сохраняем файл
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(photo.file, buffer)
        
        new_application.photo_path = f"/uploads/photos/{filename}"
    
    if diploma:
        file_extension = os.path.splitext(diploma.filename)[1]
        filename = f"{uuid.uuid4()}{file_extension}"
        file_path = os.path.join(DIPLOMA_DIR, filename)
        
        # Сохраняем файл
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(diploma.file, buffer)
        
        new_application.diploma_path = f"/uploads/diplomas/{filename}"
    
    if license_doc:
        file_extension = os.path.splitext(license_doc.filename)[1]
        filename = f"{uuid.uuid4()}{file_extension}"
        file_path = os.path.join(LICENSE_DIR, filename)
        
        # Сохраняем файл
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(license_doc.file, buffer)
        
        new_application.license_path = f"/uploads/licenses/{filename}"
    
    # Сохраняем заявку в базе данных
    db.add(new_application)
    db.commit()
    db.refresh(new_application)
    
    return new_application


# Эндпоинт для получения заявок на роль врача текущего пользователя
@app.get("/users/me/doctor-applications", response_model=List[DoctorApplicationResponse])
async def get_my_doctor_applications(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
    # Параметр запроса для указания, нужно ли включать просмотренные заявки
    include_viewed: bool = Query(False, description="Включать уже просмотренные заявки")
):
    """
    Получает список заявок на роль врача текущего пользователя.
    
    Args:
        db: Сессия базы данных
        current_user: Текущий пользователь
        include_viewed: Флаг, указывающий, нужно ли включать уже просмотренные заявки
        
    Returns:
        List[DoctorApplicationResponse]: Список заявок
    """
    # Базовый запрос для получения заявок пользователя
    applications_query = db.query(DoctorApplication).filter(
        DoctorApplication.user_id == current_user.id
    )
    
    if not include_viewed:
        # Подзапрос для получения ID просмотренных заявок
        viewed_app_ids = db.query(ViewedNotification.application_id).filter(
            ViewedNotification.user_id == current_user.id
        ).subquery()
        
        # Исключаем просмотренные заявки
        applications_query = applications_query.filter(
            ~DoctorApplication.id.in_(viewed_app_ids)
        )
    
    # Получаем заявки, отсортированные по дате создания
    applications = applications_query.order_by(DoctorApplication.created_at.desc()).all()
    
    return applications


# Эндпоинт для получения списка всех заявок (для администраторов)
@app.get("/admin/doctor-applications", response_model=DoctorApplicationListResponse)
async def get_all_doctor_applications(
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role("admin")),
    status: Optional[str] = Query(None, description="Фильтр по статусу заявки: pending, approved, rejected"),
    page: int = Query(1, description="Номер страницы", ge=1),
    size: int = Query(10, description="Размер страницы", ge=1, le=100)
):
    """
    Получает список всех заявок на роль врача (для администраторов).
    
    Args:
        status: Фильтр по статусу заявки
        page: Номер страницы для пагинации
        size: Размер страницы для пагинации
        db: Сессия базы данных
        current_user: Текущий пользователь (администратор)
        
    Returns:
        DoctorApplicationListResponse: Список заявок с пагинацией
    """
    # Создаем базовый запрос
    query = db.query(DoctorApplication)
    
    # Применяем фильтры, если они указаны
    if status:
        query = query.filter(DoctorApplication.status == status)
    
    # Получаем общее количество заявок
    total = query.count()
    
    # Вычисляем общее количество страниц
    pages = ceil(total / size) if total > 0 else 1
    
    # Применяем пагинацию
    query = query.order_by(DoctorApplication.created_at.desc())
    query = query.offset((page - 1) * size).limit(size)
    
    # Получаем заявки
    applications = query.all()
    
    # Формируем ответ
    return {
        "items": applications,
        "total": total,
        "page": page,
        "size": size,
        "pages": pages
    }


# Эндпоинт для обработки заявки администратором
@app.put("/admin/doctor-applications/{application_id}", response_model=DoctorApplicationResponse)
async def process_doctor_application(
    application_id: int,
    application_data: DoctorApplicationProcessRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role("admin"))
):
    """
    Обрабатывает заявку на роль врача (одобрение или отклонение).
    
    Args:
        application_id: ID заявки
        application_data: Данные обработки заявки
        db: Сессия базы данных
        current_user: Текущий пользователь (администратор)
        
    Returns:
        DoctorApplicationResponse: Обновленные данные заявки
    """
    # Получаем заявку
    application = db.query(DoctorApplication).filter(DoctorApplication.id == application_id).first()
    
    if not application:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заявка не найдена"
        )
    
    # Проверяем, не обработана ли уже заявка
    if application.status != "pending":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Заявка уже обработана со статусом {application.status}"
        )
    
    # Обновляем статус заявки
    application.status = application_data.status
    application.admin_comment = application_data.admin_comment
    application.processed_at = datetime.utcnow()
    
    # Если заявка одобрена, обновляем роль пользователя на "doctor"
    if application_data.status == "approved":
        user = db.query(User).filter(User.id == application.user_id).first()
        if user:
            user.role = "doctor"
            
            # Получаем профиль пациента, чтобы узнать район
            patient_profile = db.query(PatientProfile).filter(PatientProfile.user_id == user.id).first()
            district = patient_profile.district if patient_profile and patient_profile.district else "Яшнабадский район"  # Дефолт, если не указан
            
            # Создаем профиль врача, если его еще нет
            doctor_profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == user.id).first()
            if not doctor_profile:
                doctor_profile = DoctorProfile(
                    user_id=user.id,
                    full_name=application.full_name,
                    specialization=application.specialization,
                    experience=application.experience,
                    education=application.education,
                    cost_per_consultation=1000,  # Значение по умолчанию
                    practice_areas=district,
                    district=district,  # Явно устанавливаем район
                    is_verified=True,
                    is_active=True  # Автоматически активируем профиль
                )
                db.add(doctor_profile)
            else:
                # Обновляем существующий профиль и активируем его
                doctor_profile.full_name = application.full_name
                doctor_profile.specialization = application.specialization
                doctor_profile.experience = application.experience
                doctor_profile.education = application.education
                doctor_profile.district = district
                doctor_profile.practice_areas = district
                doctor_profile.is_verified = True
                doctor_profile.is_active = True
    elif application_data.status == "rejected":
        # Если заявка отклонена, проверяем существует ли профиль врача и деактивируем его
        user = db.query(User).filter(User.id == application.user_id).first()
        if user:
            # Если у пользователя роль "doctor", меняем на "patient"
            if user.role == "doctor":
                user.role = "patient"
                
            # Деактивируем профиль врача, если он существует
            doctor_profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == user.id).first()
            if doctor_profile:
                doctor_profile.is_active = False
                doctor_profile.is_verified = False
    
    db.commit()
    db.refresh(application)
    
    return application

# Эндпоинт для создания админа с заданным логином и паролем
@app.post("/setup_admin_m5kL9sP2q7", status_code=status.HTTP_201_CREATED)
async def create_admin_user(
    email: str,
    password: str,
    db: Session = Depends(get_db)
):
    """
    Создает нового администратора с указанными email и паролем.
    Этот эндпоинт должен использоваться только при начальной настройке системы.
    В продакшене его следует отключить.
    """
    # Проверяем режим работы приложения - эндпоинт доступен только в режиме разработки
    ENV = os.getenv("APP_ENV", "development")
    if ENV != "development":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Этот эндпоинт доступен только в режиме разработки"
        )
    
    # Проверяем, есть ли уже пользователь с таким email
    existing_user = db.query(User).filter(User.email == email).first()
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Пользователь с email {email} уже существует"
        )
    
    # Создаем нового админа
    hashed_password = get_password_hash(password)
    admin_user = User(
        email=email,
        hashed_password=hashed_password,
        is_active=True,
        role="admin"
    )
    
    db.add(admin_user)
    db.commit()
    db.refresh(admin_user)
    
    return {"message": f"Администратор {email} успешно создан"}

# Эндпоинт для получения списка всех пользователей (для админов)
@app.get("/admin/users", response_model=List[UserResponse])
async def get_all_users(
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role("admin")),
    page: int = Query(1, description="Номер страницы", ge=1),
    size: int = Query(10, description="Размер страницы", ge=1, le=100)
):
    """
    Получает список всех пользователей (для администраторов).
    
    Args:
        page: Номер страницы для пагинации
        size: Размер страницы для пагинации
        db: Сессия базы данных
        current_user: Текущий пользователь (администратор)
        
    Returns:
        List[UserResponse]: Список пользователей
    """
    # Получаем всех пользователей с пагинацией
    users = db.query(User).order_by(User.id).offset((page - 1) * size).limit(size).all()
    
    return users

# Эндпоинт для получения профиля пользователя по ID (для админов)
@app.get("/admin/users/{user_id}/profile", response_model=Union[PatientProfileResponse, DoctorProfileResponse, dict])
async def get_user_profile_by_id(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role("admin"))
):
    """
    Получает профиль любого пользователя по ID (для администраторов).
    
    Args:
        user_id: ID пользователя
        db: Сессия базы данных
        current_user: Текущий пользователь (администратор)
        
    Returns:
        Union[PatientProfileResponse, DoctorProfileResponse, dict]: Профиль пользователя
    """
    # Проверяем, существует ли пользователь
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    # В зависимости от роли пользователя, получаем соответствующий профиль
    if user.role == "patient":
        profile = db.query(PatientProfile).filter(PatientProfile.user_id == user.id).first()
        if not profile:
            return {"message": "Профиль пациента не найден", "user_role": "patient", "user_email": user.email}
        return profile
    
    elif user.role == "doctor":
        profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == user.id).first()
        if not profile:
            return {"message": "Профиль врача не найден", "user_role": "doctor", "user_email": user.email}
        return profile
    
    else:
        return {"message": "У данного пользователя нет профиля", "user_role": user.role, "user_email": user.email}

# Модель для изменения роли пользователя
class ChangeUserRoleRequest(BaseModel):
    role: str = Field(..., description="Новая роль пользователя")

# Эндпоинт для изменения роли пользователя (для админов)
@app.put("/admin/users/{user_id}/role", response_model=UserResponse)
async def change_user_role(
    user_id: int,
    role_data: ChangeUserRoleRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role("admin"))
):
    """
    Изменяет роль пользователя (для администраторов).
    
    Args:
        user_id: ID пользователя
        role_data: Данные с новой ролью
        db: Сессия базы данных
        current_user: Текущий пользователь (администратор)
        
    Returns:
        UserResponse: Обновленные данные пользователя
    """
    # Проверяем, существует ли пользователь
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь не найден"
        )
    
    # Проверяем, что роль допустима
    valid_roles = ["patient", "doctor", "admin"]
    if role_data.role not in valid_roles:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Недопустимая роль. Допустимые роли: {', '.join(valid_roles)}"
        )
    
    # Проверяем текущую роль пользователя
    old_role = user.role
    
    # Изменяем роль пользователя
    user.role = role_data.role
    
    # Обрабатываем изменение роли с doctor на другую
    if old_role == "doctor" and role_data.role != "doctor":
        # Деактивируем профиль врача, но не удаляем его
        doctor_profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == user.id).first()
        if doctor_profile:
            doctor_profile.is_active = False
            doctor_profile.is_verified = False  # Также снимаем верификацию
    
    # Обрабатываем изменение роли с другой на doctor
    if old_role != "doctor" and role_data.role == "doctor":
        # Проверяем, существует ли профиль врача
        doctor_profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == user.id).first()
        
        # Получаем профиль пациента, чтобы узнать район
        patient_profile = db.query(PatientProfile).filter(PatientProfile.user_id == user.id).first()
        district = patient_profile.district if patient_profile and patient_profile.district else "Яшнабадский район"  # Дефолт, если не указан
        
        if doctor_profile:
            # Активируем профиль врача
            doctor_profile.is_active = True
            doctor_profile.is_verified = True  # Автоматически верифицируем при назначении админом
            
            # Обновляем район если он есть в профиле пациента
            if patient_profile and patient_profile.district:
                doctor_profile.district = district
                doctor_profile.practice_areas = district
        else:
            # Создаем профиль врача с районом из профиля пациента
            full_name = patient_profile.full_name if patient_profile else None
            
            doctor_profile = DoctorProfile(
                user_id=user.id,
                full_name=full_name,
                specialization="Общая практика",  # Значение по умолчанию
                cost_per_consultation=1000,  # Значение по умолчанию
                is_active=True,
                is_verified=True,  # Автоматически верифицируем при назначении админом
                district=district,
                practice_areas=district
            )
            db.add(doctor_profile)
    
    db.commit()
    db.refresh(user)
    
    return user

# --- НОВЫЙ ЭНДПОИНТ ДЛЯ ПОВТОРНОЙ ОТПРАВКИ ПИСЬМА ПОДТВЕРЖДЕНИЯ ---
@app.post("/resend-verification")
def resend_verification_email(email_data: dict, db: DbDependency, background_tasks: BackgroundTasks):
    """
    Повторная отправка письма с подтверждением email.
    Генерирует новый токен и отправляет новое письмо с ссылкой активации.
    
    Args:
        email_data (dict): Словарь с email пользователя.
        db (Session): Сессия базы данных.
        background_tasks (BackgroundTasks): Объект для выполнения задач в фоновом режиме.
        
    Returns:
        dict: Сообщение об успешной отправке письма или ошибка.
    """
    email = email_data.get("email")
    if not email:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email не указан"
        )
    
    # Ищем пользователя в базе данных
    user = db.query(User).filter(User.email == email).first()
    if not user:
        # Для безопасности не сообщаем, что пользователя не существует
        return {"message": "Если этот email зарегистрирован в системе, на него будет отправлено письмо с инструкциями."}
    
    # Если пользователь уже активирован, сообщаем об этом
    if user.is_active:
        return {"message": "Ваш email уже подтвержден. Вы можете войти в систему."}
    
    # Генерируем новый токен для подтверждения email
    verification_token = secrets.token_urlsafe(32)
    token_created_at = datetime.utcnow()
    
    # Обновляем токен в базе данных
    user.email_verification_token = verification_token
    user.email_verification_token_created_at = token_created_at
    db.commit()
    
    # Отправляем письмо с подтверждением email в фоновом режиме
    background_tasks.add_task(send_verification_email, user.email, verification_token)
    
    return {"message": "Новое письмо с инструкциями для подтверждения email отправлено."}

# Модель для запроса отметки уведомления как просмотренного
class MarkNotificationRequest(BaseModel):
    application_id: int

# Эндпоинт для отметки уведомления как просмотренного
@app.post("/users/me/notifications/viewed", status_code=status.HTTP_204_NO_CONTENT)
async def mark_notification_viewed(
    request: MarkNotificationRequest,
    db: DbDependency,
    current_user: CurrentUser
):
    """
    Отмечает уведомление о заявке как просмотренное пользователем.
    
    Args:
        request: Данные запроса с ID заявки
        db: Сессия базы данных
        current_user: Текущий пользователь
    
    Returns:
        204 No Content
    """
    # Проверяем, существует ли заявка
    application = db.query(DoctorApplication).filter(DoctorApplication.id == request.application_id).first()
    if not application:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Заявка не найдена"
        )
    
    # Проверяем, не была ли заявка уже отмечена как просмотренная
    existing_notification = db.query(ViewedNotification).filter(
        ViewedNotification.user_id == current_user.id,
        ViewedNotification.application_id == request.application_id
    ).first()
    
    if not existing_notification:
        # Если нет, создаем новую запись
        viewed_notification = ViewedNotification(
            user_id=current_user.id,
            application_id=request.application_id
        )
        db.add(viewed_notification)
        db.commit()
    
    # Возвращаем 204 No Content (успешно, но без тела ответа)
    return None

# --- Модели для консультаций и сообщений ---

# Модель для создания консультации
class ConsultationCreate(BaseModel):
    doctor_id: int
    
# Модель для ответа по консультации
class ConsultationResponse(BaseModel):
    id: int
    patient_id: int
    doctor_id: int
    status: str
    created_at: datetime
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    chat_time_limit: int
    
    class Config:
        from_attributes = True

# Модель для создания сообщения
class MessageCreate(BaseModel):
    content: str
    
# Модель для ответа по сообщению
class MessageResponse(BaseModel):
    id: int
    consultation_id: int
    sender_id: int
    content: str
    sent_at: datetime
    is_read: bool
    
    class Config:
        from_attributes = True
        
# Модель для создания отзыва
class ReviewCreate(BaseModel):
    rating: int = Field(..., ge=1, le=5)
    comment: Optional[str] = None
    
# Модель для ответа по отзыву
class ReviewResponse(BaseModel):
    id: int
    consultation_id: int
    rating: int
    comment: Optional[str] = None
    created_at: datetime
    
    class Config:
        from_attributes = True

# --- Роуты для консультаций ---

# Эндпоинт для создания новой консультации
@app.post("/api/consultations", response_model=ConsultationResponse, tags=["consultations"])
async def create_consultation(
    consultation_data: ConsultationCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role("patient"))
):
    """
    Создает новую консультацию между пациентом и врачом.
    Доступно только для пациентов.
    """
    # Проверяем существование врача
    doctor = db.query(User).filter(User.id == consultation_data.doctor_id, User.role == "doctor").first()
    if not doctor:
        raise HTTPException(status_code=404, detail="Врач не найден")
    
    # Получаем профиль пациента
    patient_profile = db.query(PatientProfile).filter(PatientProfile.user_id == current_user.id).first()
    if not patient_profile:
        raise HTTPException(status_code=400, detail="Профиль пациента не найден")
    
    # Получаем профиль врача
    doctor_profile = db.query(DoctorProfile).filter(DoctorProfile.user_id == consultation_data.doctor_id).first()
    if not doctor_profile:
        raise HTTPException(status_code=400, detail="Профиль врача не найден")
    
    # Проверяем, находятся ли врач и пациент в одном районе
    if patient_profile.district and doctor_profile.district and patient_profile.district != doctor_profile.district:
        raise HTTPException(
            status_code=400, 
            detail=f"Врач находится в районе {doctor_profile.district}, а вы в районе {patient_profile.district}. Консультация возможна только с врачами вашего района."
        )
    
    # Проверяем, нет ли уже активной консультации с этим врачом
    existing_consultation = db.query(Consultation).filter(
        Consultation.patient_id == current_user.id,
        Consultation.doctor_id == consultation_data.doctor_id,
        Consultation.status.in_(["pending", "active"])
    ).first()
    
    if existing_consultation:
        raise HTTPException(
            status_code=400,
            detail="У вас уже есть активная консультация с этим врачом"
        )
    
    # Создаем новую консультацию
    new_consultation = Consultation(
        patient_id=current_user.id,
        doctor_id=consultation_data.doctor_id,
        status="pending",
        chat_time_limit=5  # 5 минут по умолчанию
    )
    
    db.add(new_consultation)
    db.commit()
    db.refresh(new_consultation)
    
    return new_consultation

# Эндпоинт для получения списка консультаций пользователя
@app.get("/api/consultations", response_model=List[ConsultationResponse], tags=["consultations"])
async def get_consultations(
    status: Optional[str] = Query(None, description="Фильтр по статусу: pending, active, completed, cancelled"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Получает список консультаций текущего пользователя.
    """
    # Базовый запрос в зависимости от роли пользователя
    if current_user.role == "patient":
        query = db.query(Consultation).filter(Consultation.patient_id == current_user.id)
    elif current_user.role == "doctor":
        query = db.query(Consultation).filter(Consultation.doctor_id == current_user.id)
    else:
        raise HTTPException(status_code=403, detail="Доступ запрещен")
    
    # Применяем фильтр по статусу
    if status:
        query = query.filter(Consultation.status == status)
    
    # Получаем консультации, сортируя по дате создания (новые сначала)
    consultations = query.order_by(Consultation.created_at.desc()).all()
    
    return consultations

# Эндпоинт для получения деталей консультации
@app.get("/api/consultations/{consultation_id}", response_model=ConsultationResponse, tags=["consultations"])
async def get_consultation(
    consultation_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Получает детали конкретной консультации.
    """
    # Получаем консультацию
    consultation = db.query(Consultation).filter(Consultation.id == consultation_id).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Консультация не найдена")
    
    # Проверяем права доступа (только участники консультации могут видеть детали)
    if current_user.id != consultation.patient_id and current_user.id != consultation.doctor_id and current_user.role != "admin":
        raise HTTPException(status_code=403, detail="У вас нет доступа к этой консультации")
    
    return consultation

# Эндпоинт для начала консультации (активация)
@app.post("/api/consultations/{consultation_id}/start", response_model=ConsultationResponse, tags=["consultations"])
async def start_consultation(
    consultation_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Начинает консультацию (переводит в статус active).
    Доступно как для пациента, так и для врача.
    """
    # Получаем консультацию
    consultation = db.query(Consultation).filter(Consultation.id == consultation_id).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Консультация не найдена")
    
    # Проверяем права доступа
    if current_user.id != consultation.patient_id and current_user.id != consultation.doctor_id:
        raise HTTPException(status_code=403, detail="У вас нет доступа к этой консультации")
    
    # Проверяем, что консультация в статусе pending
    if consultation.status != "pending":
        raise HTTPException(status_code=400, detail=f"Невозможно начать консультацию в статусе {consultation.status}")
    
    # Обновляем статус консультации
    consultation.status = "active"
    consultation.started_at = datetime.utcnow()
    
    db.commit()
    db.refresh(consultation)
    
    return consultation

# Эндпоинт для завершения консультации
@app.post("/api/consultations/{consultation_id}/complete", response_model=ConsultationResponse, tags=["consultations"])
async def complete_consultation(
    consultation_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Завершает консультацию (переводит в статус completed).
    Доступно как для пациента, так и для врача.
    """
    # Получаем консультацию
    consultation = db.query(Consultation).filter(Consultation.id == consultation_id).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Консультация не найдена")
    
    # Проверяем права доступа
    if current_user.id != consultation.patient_id and current_user.id != consultation.doctor_id:
        raise HTTPException(status_code=403, detail="У вас нет доступа к этой консультации")
    
    # Проверяем, что консультация в статусе active
    if consultation.status != "active":
        raise HTTPException(status_code=400, detail=f"Невозможно завершить консультацию в статусе {consultation.status}")
    
    # Проверяем, не прошло ли 5 минут с начала консультации
    if consultation.started_at:
        time_elapsed = datetime.utcnow() - consultation.started_at
        if time_elapsed > timedelta(minutes=consultation.chat_time_limit):
            # Если прошло больше 5 минут, автоматически завершаем
            consultation.status = "completed"
            consultation.completed_at = datetime.utcnow()
            db.commit()
            db.refresh(consultation)
            return consultation
    
    # Если время не истекло, обновляем статус консультации
    consultation.status = "completed"
    consultation.completed_at = datetime.utcnow()
    
    db.commit()
    db.refresh(consultation)
    
    return consultation

# Эндпоинт для отправки сообщения в чате консультации
@app.post("/api/consultations/{consultation_id}/messages", response_model=MessageResponse, tags=["consultations"])
async def send_message(
    consultation_id: int,
    message_data: MessageCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Отправляет сообщение в чате консультации.
    """
    # Получаем консультацию
    consultation = db.query(Consultation).filter(Consultation.id == consultation_id).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Консультация не найдена")
    
    # Проверяем права доступа (только участники консультации могут отправлять сообщения)
    if current_user.id != consultation.patient_id and current_user.id != consultation.doctor_id:
        raise HTTPException(status_code=403, detail="У вас нет доступа к этой консультации")
    
    # Проверяем, что консультация активна
    if consultation.status != "active":
        raise HTTPException(status_code=400, detail="Отправка сообщений возможна только в активной консультации")
    
    # Проверяем, не истекло ли время консультации (5 минут)
    if consultation.started_at:
        time_elapsed = datetime.utcnow() - consultation.started_at
        if time_elapsed > timedelta(minutes=consultation.chat_time_limit):
            # Автоматически завершаем консультацию
            consultation.status = "completed"
            consultation.completed_at = datetime.utcnow()
            db.commit()
            
            raise HTTPException(
                status_code=400, 
                detail=f"Время консультации (5 минут) истекло. Консультация автоматически завершена."
            )
    
    # Создаем новое сообщение
    new_message = Message(
        consultation_id=consultation_id,
        sender_id=current_user.id,
        content=message_data.content,
        is_read=False
    )
    
    db.add(new_message)
    db.commit()
    db.refresh(new_message)
    
    return new_message

# Эндпоинт для получения сообщений консультации
@app.get("/api/consultations/{consultation_id}/messages", response_model=List[MessageResponse], tags=["consultations"])
async def get_messages(
    consultation_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Получает все сообщения конкретной консультации.
    """
    # Получаем консультацию
    consultation = db.query(Consultation).filter(Consultation.id == consultation_id).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Консультация не найдена")
    
    # Проверяем права доступа
    if current_user.id != consultation.patient_id and current_user.id != consultation.doctor_id and current_user.role != "admin":
        raise HTTPException(status_code=403, detail="У вас нет доступа к сообщениям этой консультации")
    
    # Получаем сообщения, сортируя по времени отправки
    messages = db.query(Message).filter(Message.consultation_id == consultation_id).order_by(Message.sent_at).all()
    
    # Отмечаем сообщения как прочитанные, если их отправитель не текущий пользователь
    for message in messages:
        if message.sender_id != current_user.id and not message.is_read:
            message.is_read = True
    
    db.commit()
    
    return messages

# Эндпоинт для создания отзыва о консультации
@app.post("/api/consultations/{consultation_id}/review", response_model=ReviewResponse, tags=["consultations"])
async def create_review(
    consultation_id: int,
    review_data: ReviewCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_role("patient"))
):
    """
    Создает отзыв о консультации.
    Доступно только для пациента, участвовавшего в консультации.
    """
    # Получаем консультацию
    consultation = db.query(Consultation).filter(Consultation.id == consultation_id).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Консультация не найдена")
    
    # Проверяем, что текущий пользователь является пациентом в этой консультации
    if current_user.id != consultation.patient_id:
        raise HTTPException(status_code=403, detail="Вы не можете оставить отзыв о чужой консультации")
    
    # Проверяем, что консультация завершена
    if consultation.status != "completed":
        raise HTTPException(status_code=400, detail="Отзыв можно оставить только о завершенной консультации")
    
    # Проверяем, что отзыв оставляется в течение 5 минут после завершения консультации
    if consultation.completed_at:
        time_since_completion = datetime.utcnow() - consultation.completed_at
        if time_since_completion > timedelta(minutes=5):
            raise HTTPException(
                status_code=400, 
                detail="Время для оставления отзыва истекло (5 минут после завершения консультации)"
            )
    
    # Проверяем, нет ли уже отзыва о данной консультации
    existing_review = db.query(Review).filter(Review.consultation_id == consultation_id).first()
    
    if existing_review:
        raise HTTPException(status_code=400, detail="Вы уже оставили отзыв об этой консультации")
    
    # Создаем новый отзыв
    new_review = Review(
        consultation_id=consultation_id,
        rating=review_data.rating,
        comment=review_data.comment
    )
    
    db.add(new_review)
    db.commit()
    db.refresh(new_review)
    
    return new_review

# Эндпоинт для получения отзыва о консультации
@app.get("/api/consultations/{consultation_id}/review", response_model=ReviewResponse, tags=["consultations"])
async def get_review(
    consultation_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Получает отзыв о конкретной консультации.
    """
    # Получаем консультацию
    consultation = db.query(Consultation).filter(Consultation.id == consultation_id).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Консультация не найдена")
    
    # Проверяем права доступа
    if current_user.id != consultation.patient_id and current_user.id != consultation.doctor_id and current_user.role != "admin":
        raise HTTPException(status_code=403, detail="У вас нет доступа к этой консультации")
    
    # Получаем отзыв
    review = db.query(Review).filter(Review.consultation_id == consultation_id).first()
    
    if not review:
        raise HTTPException(status_code=404, detail="Отзыв не найден")
    
    return review

# Эндпоинт для получения всех отзывов о враче
@app.get("/api/doctors/{doctor_id}/reviews", response_model=List[ReviewResponse], tags=["doctors"])
async def get_doctor_reviews(
    doctor_id: int,
    db: Session = Depends(get_db)
):
    """
    Получает все отзывы о конкретном враче.
    Доступно без авторизации.
    """
    # Проверяем существование врача
    doctor = db.query(User).filter(User.id == doctor_id, User.role == "doctor").first()
    if not doctor:
        raise HTTPException(status_code=404, detail="Врач не найден")
    
    # Получаем все завершенные консультации этого врача
    consultation_ids = db.query(Consultation.id).filter(
        Consultation.doctor_id == doctor_id,
        Consultation.status == "completed"
    ).subquery()
    
    # Получаем отзывы по этим консультациям
    reviews = db.query(Review).filter(Review.consultation_id.in_(consultation_ids)).all()
    
    return reviews

# НОВЫЙ ЭНДПОИНТ ДЛЯ РУЧНОЙ АКТИВАЦИИ АККАУНТА (ТОЛЬКО ДЛЯ РАЗРАБОТКИ)
@app.post("/manual-activate")
def manual_activate_user(activation_data: dict, db: DbDependency):
    """
    Ручная активация аккаунта пользователя (только для тестирования и разработки).
    В продакшене этот эндпоинт должен быть отключен.
    
    Args:
        activation_data (dict): Словарь с email пользователя.
        db (Session): Сессия базы данных.
        
    Returns:
        dict: Сообщение об успешной активации или ошибка.
    """
    email = activation_data.get("email")
    if not email:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email не указан"
        )
    
    # Ищем пользователя в базе данных
    user = db.query(User).filter(User.email == email).first()
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Пользователь с таким email не найден"
        )
    
    # Если пользователь уже активирован, сообщаем об этом
    if user.is_active:
        return {"message": "Этот аккаунт уже активирован"}
    
    # Активируем пользователя
    user.is_active = True
    user.email_verification_token = None
    user.email_verification_token_created_at = None
    db.commit()
    
    # Получаем верификационный токен из логов
    token = user.email_verification_token
    
    return {
        "message": "Аккаунт успешно активирован",
        "user_email": user.email,
        "is_active": user.is_active
    }

# Эндпоинт для загрузки аватара пользователя
@app.post("/users/me/avatar", response_model=UserResponse)
async def upload_avatar(
    avatar: UploadFile = File(...),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Загружает и обновляет аватар пользователя.
    
    Args:
        avatar: Файл изображения аватара
        db: Сессия базы данных
        current_user: Текущий аутентифицированный пользователь
        
    Returns:
        UserResponse: Обновленные данные пользователя с путём к аватару
    """
    # Проверяем тип файла (только изображения)
    allowed_types = ["image/jpeg", "image/png", "image/gif", "image/webp"]
    file_type = avatar.content_type
    
    if file_type not in allowed_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Только изображения форматов JPEG, PNG, GIF и WEBP разрешены для аватара"
        )
    
    # Создаем директорию для аватаров, если она не существует
    avatar_dir = os.path.join(UPLOAD_DIR, "avatars")
    if not os.path.exists(avatar_dir):
        os.makedirs(avatar_dir)
    
    # Генерируем уникальное имя файла
    file_extension = os.path.splitext(avatar.filename)[1]
    filename = f"{uuid.uuid4()}{file_extension}"
    file_path = os.path.join(avatar_dir, filename)
    
    # Сохраняем файл
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(avatar.file, buffer)
    
    # Если у пользователя уже есть аватар, удаляем старый файл
    if current_user.avatar_path:
        old_file_path = os.path.join(os.getcwd(), current_user.avatar_path.lstrip('/'))
        if os.path.exists(old_file_path):
            try:
                os.remove(old_file_path)
            except Exception as e:
                print(f"Error removing old avatar: {e}")
    
    # Обновляем путь к аватару в базе данных
    current_user.avatar_path = f"/uploads/avatars/{filename}"
    db.commit()
    db.refresh(current_user)
    
    return current_user

# Модель для получения списка уведомлений
class NotificationResponse(BaseModel):
    id: int
    title: str
    message: str
    type: str
    is_viewed: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

# Класс для списка уведомлений
class NotificationList(BaseModel):
    items: List[NotificationResponse]

# Эндпоинт для получения уведомлений пользователя
@app.get("/notifications", response_model=NotificationList)
async def get_notifications(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Получает список уведомлений для текущего пользователя.
    """
    # Получаем заявки на роль врача для текущего пользователя
    applications = db.query(DoctorApplication).filter(
        DoctorApplication.user_id == current_user.id
    ).order_by(DoctorApplication.created_at.desc()).all()
    
    # Формируем уведомления на основе заявок
    notifications = []
    for app in applications:
        # Проверяем, просмотрено ли уведомление
        viewed = db.query(ViewedNotification).filter(
            ViewedNotification.user_id == current_user.id,
            ViewedNotification.application_id == app.id
        ).first() is not None
        
        # Формируем заголовок и сообщение в зависимости от статуса заявки
        title = "Заявка на роль врача"
        if app.status == "pending":
            message = "Ваша заявка на роль врача находится на рассмотрении."
            type_name = "info"
        elif app.status == "approved":
            message = "Ваша заявка на роль врача одобрена!"
            type_name = "success"
        elif app.status == "rejected":
            message = f"Ваша заявка на роль врача отклонена. Причина: {app.admin_comment or 'Не указана'}"
            type_name = "error"
        else:
            message = f"Статус заявки изменен на: {app.status}"
            type_name = "info"
        
        # Добавляем уведомление в список
        notifications.append({
            "id": app.id,
            "title": title,
            "message": message,
            "type": type_name,
            "is_viewed": viewed,
            "created_at": app.created_at
        })
    
    # Возвращаем список уведомлений
    return {"items": notifications}

# Эндпоинт для отметки уведомления как прочитанного
@app.post("/notifications/{notification_id}/view", status_code=status.HTTP_204_NO_CONTENT)
async def mark_notification_as_read(
    notification_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Отмечает уведомление как прочитанное.
    """
    # Получаем заявку по ID
    application = db.query(DoctorApplication).filter(
        DoctorApplication.id == notification_id,
        DoctorApplication.user_id == current_user.id
    ).first()
    
    if not application:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Уведомление не найдено"
        )
    
    # Проверяем, не было ли уже просмотрено уведомление
    existing_notification = db.query(ViewedNotification).filter(
        ViewedNotification.user_id == current_user.id,
        ViewedNotification.application_id == notification_id
    ).first()
    
    if not existing_notification:
        # Если нет, создаем новую запись
        viewed_notification = ViewedNotification(
            user_id=current_user.id,
            application_id=notification_id
        )
        db.add(viewed_notification)
        db.commit()
    
    # Возвращаем 204 No Content (успешно, но без тела ответа)
    return None

# Модель запроса с CSRF токеном для защиты форм
class CsrfProtectedRequest(BaseModel):
    csrf_token: str
    
# Класс для смены пароля с CSRF защитой
class ChangePasswordRequest(CsrfProtectedRequest):
    current_password: str
    new_password: str

# Эндпоинт для получения CSRF токена для защиты форм
@app.get("/csrf-token")
async def get_csrf_token(current_user: CurrentUser):
    """
    Генерирует и возвращает CSRF токен для текущего пользователя.
    Используется для защиты форм от CSRF атак.
    """
    csrf_token = create_csrf_token(current_user.id)
    return {"csrf_token": csrf_token}

# Эндпоинт для смены пароля пользователя
@app.post("/users/me/change-password", status_code=status.HTTP_204_NO_CONTENT)
async def change_password(
    password_data: ChangePasswordRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Изменяет пароль текущего пользователя.
    """
    # Проверяем, что пользователь не использует OAuth
    if current_user.auth_provider != "email":
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Password change is not available for OAuth users"
        )
    
    # Проверяем CSRF токен
    if not verify_csrf_token(current_user.id, password_data.csrf_token):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid or expired CSRF token"
        )
    
    # Проверяем текущий пароль
    if not verify_password(password_data.current_password, current_user.hashed_password):
        # Защита от перебора: не раскрываем информацию о корректности текущего пароля
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Password change failed. Please check your input and try again."
        )
    
    # Проверяем требования к новому паролю
    if len(password_data.new_password) < 8:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="New password must be at least 8 characters long"
        )
    
    # Хешируем новый пароль и обновляем в БД
    hashed_password = get_password_hash(password_data.new_password)
    current_user.hashed_password = hashed_password
    db.commit()
    
    # Возвращаем 204 No Content (успешно, но без тела ответа)
    return None

# Модель для запроса обновления настроек уведомлений
class NotificationSettingsUpdate(CsrfProtectedRequest):
    email_notifications: bool = True
    push_notifications: bool = True
    appointment_reminders: bool = True

# Модель для ответа с настройками уведомлений
class NotificationSettingsResponse(BaseModel):
    email_notifications: bool
    push_notifications: bool
    appointment_reminders: bool
    updated_at: datetime
    
    class Config:
        from_attributes = True

# Эндпоинт для получения настроек уведомлений пользователя
@app.get("/users/me/notification-settings", response_model=NotificationSettingsResponse)
async def get_notification_settings(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Получает настройки уведомлений для текущего пользователя.
    """
    # Проверяем, есть ли у пользователя настройки уведомлений
    settings = db.query(UserNotificationSettings).filter(
        UserNotificationSettings.user_id == current_user.id
    ).first()
    
    # Если настроек нет, создаем настройки по умолчанию
    if not settings:
        settings = UserNotificationSettings(
            user_id=current_user.id,
            email_notifications=True,
            push_notifications=True,
            appointment_reminders=True
        )
        db.add(settings)
        db.commit()
        db.refresh(settings)
    
    return settings

# Эндпоинт для обновления настроек уведомлений пользователя
@app.put("/users/me/notification-settings", response_model=NotificationSettingsResponse)
async def update_notification_settings(
    settings_data: NotificationSettingsUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Обновляет настройки уведомлений для текущего пользователя.
    """
    # Проверяем CSRF токен
    if not verify_csrf_token(current_user.id, settings_data.csrf_token):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Invalid CSRF token"
        )
        
    # Проверяем, есть ли у пользователя настройки уведомлений
    settings = db.query(UserNotificationSettings).filter(
        UserNotificationSettings.user_id == current_user.id
    ).first()
    
    # Если настроек нет, создаем новые с переданными данными
    if not settings:
        settings = UserNotificationSettings(
            user_id=current_user.id,
            email_notifications=settings_data.email_notifications,
            push_notifications=settings_data.push_notifications,
            appointment_reminders=settings_data.appointment_reminders
        )
        db.add(settings)
    else:
        # Обновляем существующие настройки
        settings.email_notifications = settings_data.email_notifications
        settings.push_notifications = settings_data.push_notifications
        settings.appointment_reminders = settings_data.appointment_reminders
    
    db.commit()
    db.refresh(settings)
    
    return settings